#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json

SYN = 'SYN'
ACK = 'ACK'
FIN = 'FIN'

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

class send:

    def __init__(self, ip, port):
        self.dest = (ip, port)
        self.data_size = 1000
        self.msg_size = 1500
        self.sequence = 0
        # Set up the socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.settimeout(30)
        self.previous_packet = None
        self.previous_sent = None

        self.RTT = datetime.timedelta(seconds=3)
        self.RTO = 2 * self.RTT

        self.in_flight = {}
        self.advwnd = 3000
        self.cwnd = 3000
        self.in_order_ack = 0

    def window(self):
        return min(self.advwnd, self.cwnd)

    def effective_window(self):
        # window size - ( bytes sent - first byte in window acked)
        keys = self.in_flight.keys()
        return self.window() - (self.sequence - self.in_order_ack)

    def estimateRTT(self):
        self.RTT = ( 9 * self.RTT +  (datetime.datetime.now() - self.previous_sent) ) / 10
        self.RTO = 2 * self.RTT

    def send_packet(self, packet, seq_num):
        if self.sock.sendto(packet, self.dest) < len(packet):
            log("[error] unable to fully send packet")
        else:
            log("[send data] " + str(seq_num) + " (" + str(len(packet)) + ")")

    def send_next_packet(self):
        data = sys.stdin.read(self.data_size)
        if (len(data) > 0):
            msg = json.dumps({"sequence": self.sequence, "data": data, "type": ACK})
            self.sequence += len(data)
            self.in_flight[self.sequence] = (datetime.datetime.now(), msg)
            self.send_packet(msg, self.sequence)
            return True
        else:
            msg = json.dumps({"type": FIN, "data": "", "sequence": self.sequence})
            self.in_flight[self.sequence + 1] = (datetime.datetime.now(), msg)
            self.send_packet(msg, self.sequence + 1)
            log('[send FIN]')
            self.advwnd = 0
            return False

    def handle_timeout(self, ack_num):
        msg = self.in_flight[ack_num][1]
        self.send_packet(msg, ack_num)
        self.in_flight[ack_num] = (datetime.datetime.now(), msg)

    def open_connection(self):
        pass

    def send_data(self):
        keep_open = True
        self.send_next_packet()
        while keep_open or len(self.in_flight):
            now = datetime.datetime.now()
            for ack_num in self.in_flight:
                if now - self.in_flight[ack_num][0] > self.RTO:
                    self.handle_timeout(ack_num)
            if self.effective_window() > 0:
                keep_open = self.send_next_packet()
            if select.select([self.sock], [], [], 0.25)[0]:
                (data, addr) = self.sock.recvfrom(self.msg_size)
                try:
                    decoded = json.loads(data)
                    msg_type =  decoded['type']
                    if msg_type == ACK:
                        self.in_order_ack = decoded['ack']
                        sack = decoded['sack']
                        log("[recv ack] " + str(sack))
                        if sack in self.in_flight:
                            del self.in_flight[sack]
                except ValueError, KeyError:
                    log("[recv corrupt packet]")

    def close_connection(self):
        while True:
            if select.select([self.sock], [], [], 0.25)[0]:
                (data, addr) = self.sock.recvfrom(self.msg_size)
                try:
                    decoded = json.loads(data)
                    if (decoded['type'] == FIN):
                        msg = json.dumps({'type': ACK, 'sequence': decoded['sequence'] + 1})
                        self.send_packet(msg, decoded['sequence'] + 1)
                        break
                except ValueError, KeyError:
                    log("[recv corrupt packet]")

    def run(self):
        self.open_connection()
        self.send_data()
        self.close_connection()

if __name__ == '__main__':
    # Bind to localhost and an ephemeral port
    IP_PORT = sys.argv[1]
    UDP_IP = IP_PORT[0:IP_PORT.find(":")]
    UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
    dest = (UDP_IP, UDP_PORT)
    send(UDP_IP, UDP_PORT).run()
