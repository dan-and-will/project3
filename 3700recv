#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json

SYN = 'SYN'
ACK = 'ACK'
FIN = 'FIN'

def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

class Receiver:

    def __init__(self):
        self.msg_size = 1500
        # Set up the socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # Bind to localhost and an ephemeral port
        self.sock.bind(("127.0.0.1", 0))
        self.sock.settimeout(30)
        log("[bound] " + str(self.sock.getsockname()[1]))

        self.sequence = 0

        self.advertised_window = 3000 # in bytes
        self.received_packets = {}
        self.ooo_acks = {} # out of order acks

    def inc_seq(self, data_seq, data_len):
        next_seq = data_seq + data_len
        for seq in sorted(self.ooo_acks.keys()):
            if seq == next_seq:
                next_seq = seq + self.ooo_acks[seq]
                del self.ooo_acks[seq]
            else:
                break
        self.sequence = next_seq

    def write_data(self):
        for ack_num in sorted(self.received_packets.keys()):
            if ack_num > self.sequence:
                break
            sys.stdout.write(self.received_packets[ack_num])
            del self.received_packets[ack_num]

    def close_connection(self, addr):
        msg = json.dumps({'type': FIN, "sequence": self.sequence})
        # timeout = datetime.datetime.timedelta(seconds)
        while True:
            if self.sock.sendto(msg, addr) < len(msg):
                log("[error] unable to fully send packet")
            else:
                log("[FIN DOOD]")
            if select.select([self.sock], [], [], 3)[0]: # guess 3 sec timeout
                (data, addr) = self.sock.recvfrom(self.msg_size)
                try:
                    decoded = json.loads(data)
                    if decoded['type'] == ACK:
                        break
                    # if decoded['type'] == FIN:
                    #     msg = json.dumps({'type': ACK, 'ack': self.sequence, 'sack': self.sequence})
                    #     if self.sock.sendto(msg, addr) < len(msg):
                    #         log("[error] unable to fully send packet")
                except (ValueError, KeyError, TypeError):
                    log("[recv corrupt packet]")
            else:
                break
        log("[completed]")

    def receive_messages(self):
        keep_open = True
        fin = -100
        while keep_open or len(self.received_packets):
            if select.select([self.sock], [], [], 0.25)[0]:
                (data, addr) = self.sock.recvfrom(self.msg_size)
                try:
                    decoded = json.loads(data)
                    seq = decoded['sequence']
                    data_len = len(decoded['data'])
                    if (decoded['type'] == FIN):
                        fin = seq
                        data_len = 1
                        log("[recv Fin] " + str(seq) + " (" + str(data_len) + ") ACCEPTED")
                    if seq == self.sequence:
                        # self.sequence = seq + data_len
                        self.inc_seq(seq, data_len)
                        log("[recv data] " + str(seq) + " (" + str(data_len) + ") ACCEPTED (in-order)")
                        self.received_packets[seq] = decoded['data']
                    elif seq > self.sequence:
                        log("[recv data] " + str(seq) + " (" + str(data_len) + ") ACCEPTED (out-of-order)")
                        self.received_packets[seq] = decoded['data']
                        self.ooo_acks[seq] = data_len
                    else:
                        log("[recv data] " + str(seq) + " (" + str(data_len) + ") IGNORED")
                    msg = json.dumps({'type': ACK, "ack": self.sequence, "sack": seq + data_len})
                    log("ABOUT TO SEND " + msg)
                    if self.sock.sendto(msg, addr) < len(msg):
                        log("[error] unable to fully send packet")
                except (ValueError, KeyError, TypeError):
                    log("[recv corrupt packet]")
            else:
                pass#log('[............] {seq}...{fin}...{packets}...{keep}'.format(seq=self.sequence, keep=keep_open, fin=fin, packets=self.received_packets.keys()))
            self.write_data()
            keep_open = self.sequence != fin + 1
        self.close_connection(addr)

    def run(self):
        self.receive_messages()

if __name__ == '__main__':
    receiver = Receiver()
    receiver.run()
